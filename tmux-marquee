#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"

# Defaults
width=30
id="default"
speed=1
separator=" - "
direction="left"
pad=true
scroll_delay=0
max_length=0
reset=false

usage() {
  cat <<'EOF'
tmux-marquee — scroll text for tmux status bar

Usage: echo "long text" | tmux-marquee [OPTIONS]

Options:
  -w, --width N        Display width in columns (default: 30)
  -i, --id NAME        Instance ID for independent state (default: "default")
  -s, --speed N        Characters to advance per tick (default: 1)
  --separator STR      Text between loop iterations (default: " - ")
  --direction DIR      Scroll direction: left, right, bounce (default: left)
  --pad                Pad short text with trailing spaces (default)
  --no-pad             Don't pad short text
  --scroll-delay N     Wait N ticks before starting scroll (default: 0)
  --max-length N       Truncate input beyond N chars (0 = unlimited)
  --reset              Clear state for this ID and exit
  --help               Show this help
  --version            Show version

Examples:
  # Basic scrolling in tmux status bar
  set -g status-right '#(my-cmd | tmux-marquee -w 30 -i sr)'

  # Use tmux's client width
  set -g status-right '#(my-cmd | tmux-marquee -w #{client_width} -i sr)'

  # Multiple independent marquees
  set -g status-right '#(cmd1 | tmux-marquee -w 20 -i a) #(cmd2 | tmux-marquee -w 20 -i b)'
EOF
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -w|--width)     width="$2"; shift 2 ;;
    -i|--id)        id="$2"; shift 2 ;;
    -s|--speed)     speed="$2"; shift 2 ;;
    --separator)    separator="$2"; shift 2 ;;
    --direction)    direction="$2"; shift 2 ;;
    --pad)          pad=true; shift ;;
    --no-pad)       pad=false; shift ;;
    --scroll-delay) scroll_delay="$2"; shift 2 ;;
    --max-length)   max_length="$2"; shift 2 ;;
    --reset)        reset=true; shift ;;
    --help)         usage ;;
    --version)      echo "tmux-marquee $VERSION"; exit 0 ;;
    *)              echo "Unknown option: $1" >&2; exit 1 ;;
  esac
done

# Unicode support: detect non-ASCII and use python3 for column-width math
has_nonascii() {
  local LC_ALL=C
  [[ "$1" == *[!$'\x01'-$'\x7e']* ]]
}

# Display width in terminal columns (CJK/emoji = 2, combining = 0)
display_width() {
  local s="$1"
  if ! has_nonascii "$s"; then
    echo "${#s}"
    return
  fi
  python3 -c "
import unicodedata, sys
s = sys.argv[1]
w = 0
for c in s:
    cat = unicodedata.east_asian_width(c)
    if cat in ('W', 'F'):
        w += 2
    elif unicodedata.category(c).startswith('M'):
        pass  # combining marks = 0 width
    else:
        w += 1
print(w)
" "$s"
}

# Extract substring by display columns (handles wide chars)
slice_columns() {
  local s="$1" offset="$2" w="$3"
  if ! has_nonascii "$s"; then
    echo "${s:$offset:$w}"
    return
  fi
  python3 -c "
import unicodedata, sys
s, offset, width = sys.argv[1], int(sys.argv[2]), int(sys.argv[3])

def char_width(c):
    cat = unicodedata.east_asian_width(c)
    if cat in ('W', 'F'):
        return 2
    if unicodedata.category(c).startswith('M'):
        return 0
    return 1

# Build column-to-char mapping
cols = []
for c in s:
    cw = char_width(c)
    cols.append((c, cw))

total_cols = sum(w for _, w in cols)
if total_cols == 0:
    print('')
    sys.exit(0)

# Advance to offset column
col = 0
idx = 0
while col < offset and idx < len(cols):
    col += cols[idx][1]
    idx += 1
    if col > total_cols:
        col %= total_cols
        idx %= len(cols)

# Collect chars for width columns
result = []
filled = 0
while filled < width:
    if idx >= len(cols):
        idx = 0
    c, cw = cols[idx]
    if filled + cw > width:
        result.append(' ')
        break
    result.append(c)
    filled += cw
    idx += 1
print(''.join(result))
" "$s" "$offset" "$w"
}

# State directory
state_dir="${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}/tmux-marquee"
mkdir -p "$state_dir"
state_file="$state_dir/$id"

# Stale state cleanup: prune files older than 1 hour (runs ~1% of invocations)
if (( RANDOM % 100 == 0 )); then
  find "$state_dir" -maxdepth 1 -type f -mmin +60 -delete 2>/dev/null || true
fi

# Handle --reset
if [[ "$reset" == true ]]; then
  rm -f "$state_file"
  exit 0
fi

# Read all stdin
text=$(cat)

# Truncate if --max-length set
if [[ "$max_length" -gt 0 ]] && [[ ${#text} -gt "$max_length" ]]; then
  text="${text:0:$max_length}"
fi

# Empty input → empty output
if [[ -z "$text" ]]; then
  rm -f "$state_file"
  echo ""
  exit 0
fi

# Compute display width
text_cols=$(display_width "$text")
unicode_mode=false
if has_nonascii "$text"; then
  unicode_mode=true
fi

# If text fits, pass through unchanged
if [[ "$text_cols" -le "$width" ]]; then
  if [[ "$pad" == true ]]; then
    pad_count=$((width - text_cols))
    printf '%s%*s\n' "$text" "$pad_count" ""
  else
    echo "$text"
  fi
  rm -f "$state_file"
  exit 0
fi

# Content hash for change detection
content_hash=$(printf '%s' "$text" | cksum | cut -d' ' -f1)

# Load state: position, hash, delay_counter
pos=0
stored_hash=""
delay_counter=0
if [[ -f "$state_file" ]]; then
  stored_hash=$(sed -n '1p' "$state_file")
  pos=$(sed -n '2p' "$state_file")
  delay_counter=$(sed -n '3p' "$state_file")
  # Reset on content change
  if [[ "$stored_hash" != "$content_hash" ]]; then
    pos=0
    delay_counter=0
  fi
fi

# Handle scroll delay
if [[ "$scroll_delay" -gt 0 ]] && [[ "$delay_counter" -lt "$scroll_delay" ]]; then
  delay_counter=$((delay_counter + 1))
  # Save state and output start of text
  tmp_file="$state_file.tmp.$$"
  printf '%s\n%s\n%s\n' "$content_hash" "0" "$delay_counter" > "$tmp_file"
  mv -f "$tmp_file" "$state_file"
  echo "${text:0:$width}"
  exit 0
fi

# Build scrollable text: text + separator (for seamless loop)
scroll_text="${text}${separator}"

if [[ "$unicode_mode" == true ]]; then
  scroll_cols=$(display_width "$scroll_text")
else
  scroll_cols=${#scroll_text}
fi

# Normalize position
pos=$((pos % scroll_cols))

# Extract visible window
if [[ "$direction" == "bounce" ]]; then
  bounce_range=$((text_cols - width))
  if [[ "$bounce_range" -le 0 ]]; then
    bounce_range=1
  fi
  cycle=$((bounce_range * 2))
  bounce_pos=$((pos % cycle))
  if [[ "$bounce_pos" -ge "$bounce_range" ]]; then
    bounce_pos=$((cycle - bounce_pos))
  fi
  if [[ "$unicode_mode" == true ]]; then
    visible=$(slice_columns "$text" "$bounce_pos" "$width")
  else
    visible="${text:$bounce_pos:$width}"
  fi
  next_pos=$((pos + speed))
elif [[ "$direction" == "right" ]]; then
  rpos=$(( (scroll_cols - pos) % scroll_cols ))
  if [[ "$unicode_mode" == true ]]; then
    visible=$(slice_columns "$scroll_text" "$rpos" "$width")
  else
    visible=""
    remaining=$width
    offset=$rpos
    while [[ "$remaining" -gt 0 ]]; do
      offset=$((offset % scroll_cols))
      avail=$((scroll_cols - offset))
      if [[ "$avail" -ge "$remaining" ]]; then
        visible="${visible}${scroll_text:$offset:$remaining}"
        remaining=0
      else
        visible="${visible}${scroll_text:$offset:$avail}"
        remaining=$((remaining - avail))
        offset=0
      fi
    done
  fi
  next_pos=$((pos + speed))
else
  # Left scroll (default)
  if [[ "$unicode_mode" == true ]]; then
    visible=$(slice_columns "$scroll_text" "$pos" "$width")
  else
    visible=""
    remaining=$width
    offset=$pos
    while [[ "$remaining" -gt 0 ]]; do
      offset=$((offset % scroll_cols))
      avail=$((scroll_cols - offset))
      if [[ "$avail" -ge "$remaining" ]]; then
        visible="${visible}${scroll_text:$offset:$remaining}"
        remaining=0
      else
        visible="${visible}${scroll_text:$offset:$avail}"
        remaining=$((remaining - avail))
        offset=0
      fi
    done
  fi
  next_pos=$((pos + speed))
fi

# Save state (atomic write)
tmp_file="$state_file.tmp.$$"
printf '%s\n%s\n%s\n' "$content_hash" "$next_pos" "$delay_counter" > "$tmp_file"
mv -f "$tmp_file" "$state_file"

echo "$visible"
